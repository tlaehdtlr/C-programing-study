### VS

- F7 컴파일
- ctrl + F5 실행
- 파일 변화
  - hello.c -> hello.obj -> hello.exe



### Debug

- 디버깅
  - 중단점 삽입/삭제 F9
  - 디버깅시작 F5
  - 중지 shift F5
  - 프로시저 단위 실행 F10
  - 한 단계씩 코드 실행 F11



### 자료형

여기 보면서 느낀 점은 window 32bit, 63bit 에 따라 sizeof 찍었을 때, 크기가 달라

이거 잘 생각하면서 해야하는건가



#### 정수

- char는 1바이트 정수라고 생각하면됨
- int
  - signed int, int
  - unsigned int, unsigned
    - 음수 아닌 정수
- short
  - signed short int ,  short
  - unsigned short int, unsigned short
- long
  - signed long int , long
  - unsigned long int , unsigned long
  - %ld
- long long
  - %lld

- unsigned 는 %u 를 사용함 (%lu %llu)
- 최대, 최소 넘으면 오버플로우, 언더플로우 발생함
- sizeof 사용!! ex) sizeof 188888;   괄호도 가능 sizeof (char) 
- 자료의 최대 최소 사용
  - #include <limits.h>
  - CHAR_MIN, SHRT_MIN, INT_MIN, LONG_MIN, LLONG_MIN (MAX도 가능 unsign 가능)
- 크기가 표시된 자료형
  - int8_t , int16_t , int32_t , int64_t



 #### 실수

- float (4바이트, 유효 7)   %f

- double (8, 16)    $f

- long double (8, 16)    $Lf

- 실제 c 표준은 유효자리 float 6, double 이 10

- ex.

  - ```
    float num1 = 0.1f;
    double num2 = 123.4567890;
    long double num3 = 5.4321l;
    ```

  - long 은 저렇게 숫자 뒤에 `l` 붙임

  - float num1 = .1f 이렇게도 가능

- 지수 표기법

  - 2.1e2 , 3.e5f 
  - 2.1e-2
  - %e, %Le

- 실수도 최댓값, 최솟값 있다잉 
- 얘네는 오버플로우되면 inf이고, 언더플로우되면 -inf 임



#### 문자

- char
- 1바이트 정수형임
- 문자에 해당하는 ASCII 코드 저장
- 작은 따옴표는 문자 2개 이상 묶을 수 없다



#### 상수

- const
- const int num = 10;
- 상수는 선언이랑 초기화 같이 해야함



#### 리터럴

- 값 그 자체
- 정수 리터럴 접미사가 있음 (나중에 이거 출력할 때, 쓸 수 있는듯?)



### 입출력

- 입력
  - getchar()
  - gets() , gets_s()
- 콘솔 입출력
  - standard input, stdin
  - standard output, stdout
- scanf(서식, 변수주소)
  - 표준입력으로 사용자 입력 받는 함수
  - stdio.h 에 있음
  - 이게 근데 뭔 컴파일 쪽에서 에러가 나나봐
    - #define _CRT_SECURE_NO_WARNINGS 써야해
    - 아니면 scanf_s 이거를 써도 되는듯
    - 아니 걍 scanf_s 쓰는게 좋은거 같다
      - 문자열의 경우 크기까지 붙여줌
        - scanf_s("%s", name, sizeof(name)) 
  - scanf("%d %d", &num1, &num2);
  - 문자열은 그냥 받음 scanf("%s", strname);
  - 단일 문자랑 문자열은 변수 뒤에 크기 넣어줄 것





### 덧뺄

- += , -= : 사용가능 굿
- ++ , -- : 1 증감
  - 포인터 연산에서 자료형 크기만큼 증감 가능







### 선택문

#### if

````c
int num;
scanf("%d", &num);
if (num>0)
{
	printf("양수");
} else if (num<0)
{
	printf("음수");
} else
{
	printf('0')
}
````

#### switch

```c
int score;
scanf("%d", &score);
switch (score/10){
    case10:
    case 9:
        printf("A학점\n");
        break
    case 8:
        printf("B학점\n");
        break
       
    ....
	default:
        printf("F");
        break;
}
```



#### goto

- goto 문 만나면 label 위치로 무조건 이동
- 반복문 바로 벗어나게 함 (break, 여러번 안해도됨, 근데 이거 잘 안쓰는게 좋다네)
- 이거 써본 결과 별로임 쓰지마
- return 잘 써 그냥





### 연산자, 비트





### 반복

#### while

- 파이썬의 while과 같음

#### do-while

- 명령문을 먼저 실행 후 조건식 확인

#### for

- 반복횟수 정해져있음
- for(초기값; 조건식; 증감식;)
- 세미콜론 2개만 있으면 저기 인자? 들 생략 가능

#### 반복 제어

- break, continue 파이썬이랑 똑같음



### 포인터

```
int a[2] = {1,2};
int *b = a;

int a[2][3] = {0};
int (*b)[3] = a;

char a[3][20] = {ads, sdf, fdg};

```

- 포인터 배열은 원소에 값이 아닌 주소를 담을 수 있음



### 메모리

- 정적 메모리 할당

  - ```
    char name[3][20] = {"김땡땡", "박땡땡", "이땡땡"}
    ```

    이러면 20 공간에 3글자만 들어가서 메모리 낭비 중

- 동적 메모리 할당

  - 포인터 변수 선언
    임의 공간 원하는 만큼 할당, 그 주소 포인터에 저장
    포인터를 이용하여 할당 받은 메모리 공간 사용
    다 쓰고 할당받은 메모리 해제하여 운영체제에 돌려줌

  - ```c
    #include <stdlib.h>
    char *str = NULL;
    str = (char*)malloc(20);
    strcpy(str, "안녕하세요");
    printf("%s \n", str);
    free(str);
    
    ```

- 메모리 관련 함수들

  - memset(포인터, 값, 바이트 수);
    - 포인터가 가리키는 주소부터 바이트수 만큼을 값으로 채움
    - 메모리 할당 받고 초기화 해주는 습관!!
  - memcpy(받은 포인터, 복사할 값 들어있는 주소, 바이트수);
    - 2차 배열 복사할 때 strcpy()는 여러번 사용해야는데 이거 하번이면 됨
  - 





### 배열

- 자료형 동일한 데이터들 모음
- 크기를 지정해준다
- int numbers[10];
- 인덱스는 0부터 시작임 파이썬이랑 같음

#### 문자열

- null 문자로 끝나는 단일문자의 연결
- null은 아스키코드 0 , char abc = '\0', char abd[10] = "\0"
- 문자열 복사
  - #include <string,h>
  - strcpy(문자열 담을 변수명, 담길 문자열 값)
  - strcpy_s 가 권장됨
  - strnspy(문자열 담을 변수명, 담을 문자열 값, 담을 크기)

- 문자열 길이
  - strlen(문자열)
    - 개행문자까지 세지 않은 것임
    - 실제 길이는 개행문자 포함이라서 +1
  - 길이 비교
    - strcmp(문자열1, 문자열2)
      - 아스키 코드값으로 변환하여 차례대로 비교
      - 1이 크면 음수, 같으면 0, 2가 크면 양수 반환
    - stricmp(문1, 문2)
      - 대소문자 구분 x



### 구조체





### 함수

- 파이썬이랑 비슷한데 리턴 타입이랑 인자 타입 정해주는 것 잊지말고, 선언을 먼저하네
- 그냥 쓰면 값에 의한 호출이고,
- `&` 이거를 앞에 붙이면 참조에 의한 호출이 됨
  - 함수 정의할 때 인자에 자료형* 이런식으로 * 이거 붙여줘야해
  - 포인터(주소) 자료형으로 쓸 수 있게

### 모듈화

